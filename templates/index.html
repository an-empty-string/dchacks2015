<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Metryx - Washington DC</title>
        <style type="text/css">
html, body, #map-canvas {
    height: 100%;
    margin: 0;
    padding: 0;
}

.loading {
    /* display: none; */
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -32.5px;
    z-index: 10;
}

#panel {
    position: absolute;
    top: 25px;
    right: 0;
    width: auto;
    padding: 5px 10px;
    z-index: 10;
    line-height: 20px;

    font-family: 'Roboto','Helvetica','Open Sans','sans-serif';
    background: rgba(242, 242, 242, 0.8);
}
        </style>
        <link rel="stylesheet" type="text/css" href="/static/spinner.css" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
        <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&amp;libraries=visualization,geometry&amp;sensor=false"></script>
        <script type="text/javascript">
var TILE_SIZE = 256;

//Mercator --BEGIN--
function bound(value, opt_min, opt_max) {
  if (opt_min !== null) value = Math.max(value, opt_min);
  if (opt_max !== null) value = Math.min(value, opt_max);
  return value;
}

function degreesToRadians(deg) {
  return deg * (Math.PI / 180);
}

function radiansToDegrees(rad) {
  return rad / (Math.PI / 180);
}

function MercatorProjection() {
  this.pixelOrigin_ = new google.maps.Point(TILE_SIZE / 2,
  TILE_SIZE / 2);
  this.pixelsPerLonDegree_ = TILE_SIZE / 360;
  this.pixelsPerLonRadian_ = TILE_SIZE / (2 * Math.PI);
}

MercatorProjection.prototype.fromLatLngToPoint = function (latLng,
opt_point) {
  var me = this;
  var point = opt_point || new google.maps.Point(0, 0);
  var origin = me.pixelOrigin_;

  point.x = origin.x + latLng.lng() * me.pixelsPerLonDegree_;

  // NOTE(appleton): Truncating to 0.9999 effectively limits latitude to
  // 89.189.  This is about a third of a tile past the edge of the world
  // tile.
  var siny = bound(Math.sin(degreesToRadians(latLng.lat())), - 0.9999,
  0.9999);
  point.y = origin.y + 0.5 * Math.log((1 + siny) / (1 - siny)) * -me.pixelsPerLonRadian_;
  return point;
};

MercatorProjection.prototype.fromPointToLatLng = function (point) {
  var me = this;
  var origin = me.pixelOrigin_;
  var lng = (point.x - origin.x) / me.pixelsPerLonDegree_;
  var latRadians = (point.y - origin.y) / -me.pixelsPerLonRadian_;
  var lat = radiansToDegrees(2 * Math.atan(Math.exp(latRadians)) - Math.PI / 2);
  return new google.maps.LatLng(lat, lng);
};

//Mercator --END--


var desiredRadiusPerPointInMeters = 700;
function getNewRadius() {
    console.log("Radius calc")
    var numTiles = 1 << map.getZoom();
    var center = map.getCenter();
    var moved = google.maps.geometry.spherical.computeOffset(center, 10000, 90); /*1000 meters to the right*/
    var projection = new MercatorProjection();
    var initCoord = projection.fromLatLngToPoint(center);
    var endCoord = projection.fromLatLngToPoint(moved);
    var initPoint = new google.maps.Point(
        initCoord.x * numTiles,
        initCoord.y * numTiles
    );
    var endPoint = new google.maps.Point(
        endCoord.x * numTiles,
        endCoord.y * numTiles
    );
    var pixelsPerMeter = (Math.abs(initPoint.x-endPoint.x))/10000.0;
    var totalPixelSize = Math.floor(desiredRadiusPerPointInMeters*pixelsPerMeter);
    console.log(totalPixelSize);
    return totalPixelSize;
 
}

var latData = [];
var railStations = {};
var railLines = {};
var railLat = [];
var stationCircles = {};

var busStops = {};
var busLat = [];
var busCircles = {};



var map;
var heatMap;


function init() {
    console.debug("init map");
    var mapOptions = {
        zoom: 10,
        center: new google.maps.LatLng(38.904815, -77.016190),
        mapTypeId: google.maps.MapTypeId.MAP,
        maxZoom: 16,
        minZoom: 10,
        styles: [{
            stylers: [{
                saturation: -100
            }]
        }]
    };

    map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);


    setupHeat(true, true);

    addStationMarkers();
}

function setupHeat(rail, bus) {

    if(heatMap) {
        heatMap.setMap(null);
        heatMap = null;
    }

    if(rail && bus) {
        latData = busLat.concat(railLat);
    } else if(rail) {
        latData = railLat;
    } else if(bus) {
        latData = busLat;
    } else {
        latData = [];
    }


    var pointList = new google.maps.MVCArray(latData);
    heatMap = new google.maps.visualization.HeatmapLayer({
        data: pointList,
        radius: getNewRadius()
    });


    var gradient = [
        'rgba(103, 147, 237, 0)',
        'rgba(103, 147, 237, 1)',
        'rgba(114, 135, 236, 1)',
        'rgba(125, 123, 235, 1)',
        'rgba(136, 110, 235, 1)',
        'rgba(147, 98, 234, 1)',
        'rgba(158, 86, 233, 1)',
        'rgba(169, 73, 233, 1)',
        'rgba(180, 61, 232, 1)',
        'rgba(191, 49, 231, 1)',
        'rgba(202, 36, 231, 1)',
        'rgba(213, 24, 230, 1)',
        'rgba(224, 12, 229, 1)',
        'rgba(235, 0, 229, 1)'
    ]
    heatMap.set('gradient', heatMap.get('gradient') ? null : gradient);




    google.maps.event.addListener(map, 'zoom_changed', function (){
        // heatMap, not map
        heatMap.setOptions({radius:getNewRadius()});
    });

    google.maps.event.addListenerOnce(map, 'idle', function(){
        // loaded fully
        endLoad();
    });

    heatMap.setMap(map);
}

var railVisible = true;
var railMarkersVisible = true;
var busVisible = false;
var busMarkersVisible = false;

function addStationMarkers() {
    var codes = Object.keys(railStations);
    for(var i=0; i<codes.length; i++) {
        var code = codes[i];
        var station = railStations[code];
        var circle = new google.maps.Circle({
            radius: 50,
            fillColor: "rgba(153,51,146,1)",
            fillOpacity: 1.0,
            strokeOpacity: 0,
            center: station.loc
        });
        circle.setMap(map);
        stationCircles[code] = circle;
    }
}

function hideStationMarkers() {
    var keys = Object.keys(stationCircles);
    for(var i=0; i<keys.length; i++) {
        var key = keys[i];
        var circle = stationCircles[key];
        circle.setMap(null);
    }
    stationCircles = {};
}

function addBusStopMarkers() {
    var ids = Object.keys(busStops);
    for(var i=0; i<ids.length; i++) {
        var id = ids[i];
        var stop = busStops[id];
        var circle = new google.maps.Circle({
            radius: 25,
            fillColor: "rgba(56,68,143,1)",
            fillOpacity: 1.0,
            strokeOpacity: 0,
            center: stop.loc
        });
        circle.setMap(map);
        busCircles[id] = circle;
    }
}

function hideBusStopMarkers() {
    var keys = Object.keys(busCircles);
    for(var i=0; i<keys.length; i++) {
        var key = keys[i];
        var circle = busCircles[key];
        circle.setMap(null);
    }
    busCircles = {};
}

google.maps.event.addDomListener(window, 'load', function() {
    initAPIcalls();
});


initAPIcalls = function() {
    $.get("/api/grab/", {}, function(d) {
        data = JSON.parse(d);
        for(var i=0; i<data["lines"].length; i++) {
            var line = data["lines"][i];
            railLines[line["line_code"]] = line;
        }
        for(var i=0; i<data["stations"].length; i++) {
            var st = data["stations"][i];
            railStations[st["station_code"]] = st;
        }
    
        $.get("/gen/export.json", {}, function(d) {
            var data = JSON.parse(d);
            var rail = data["metrorail"];
            for(var i=0; i<rail.length; i++) {
                var pt = rail[i];
                var loc = new google.maps.LatLng(
                        parseFloat(pt["lat"]), parseFloat(pt["lon"]));
                railLat.push({
                    location: loc,
                    weight: parseFloat(pt["weight"])
                });

                if(!railStations.hasOwnProperty(pt.station_code)) {
                    pt["lines"] = [pt["line"]];
                    pt["loc"] = loc;
                    railStations[pt.station_code] = pt;
                    console.error("no",pt.station_code,"?");
                } else {
                    railStations[pt.station_code]["lines"].push(pt["line"]);
                }
            }

            var bus = data["metrobus"];
            for(var i=0; i<bus.length; i++) {
                var pt = bus[i];
                var loc = new google.maps.LatLng(
                        parseFloat(pt["lat"]), parseFloat(pt["lon"]));
                busLat.push({
                    location: loc,
                    weight: parseFloat(pt["weight"])
                });

                pt["loc"] = loc;
                busStops[pt.stop_id] = pt;
            }

            init();
        }, "text");

    }, "text");
    
}

startLoad = function() {
    $("#loading").show();
}

endLoad = function() {
    $("#loading").hide();
}

boxUpdate = function() {
    var rail = $("#rail-box")[0].checked;
    var bus = $("#bus-box")[0].checked;
    var busStation = $("#bus-station-box")[0].checked;

    startLoad();

    setupHeat(rail, bus);
    if(busStation) {
        busMarkersVisible = true;
        addBusStopMarkers();
    } else {
        busMarkersVisible = false;
        hideBusStopMarkers();
    }

    endLoad();
}

        </script>
    </head>

    <body>
        <div id="loading">
            <svg class="spinner" width="65px" height="65px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
               <circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
            </svg>
        </div>
        <div id="panel">
            <input type="checkbox" id="rail-box" onchange="boxUpdate()" checked />Metrorail<br />
            <input type="checkbox" id="bus-box" onchange="boxUpdate()" />Metrobus<br />
            &nbsp; &nbsp; <input type="checkbox" id="bus-station-box" onchange="boxUpdate()" />Show stations

        </div>
        <div id="map-canvas"></div>
    </body>
</html>